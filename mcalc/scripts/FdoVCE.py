#!/usr/bin/python
"""
$ python doVCE.py <Aeff> <outfile> [<he4_fname> <he5_fname> <he6_fname>]

Generates an interaction file based on He4, He5, and He6
output files.
"""

from sys import argv


def get_e0(aeff, he4_fname):
    if he4_fname is not None:
        fname = he4_fname
    else:
        fname = 'he4_%d/he4_A%d.out' % (aeff, aeff)
    f = open(fname)
    line = f.readline()
    while 'State # 1   Energy' not in line:
        line = f.readline()
    ldat = line.split()
    e0 = float(ldat[5])
    return e0


def get_spe(aeff, e0, he5_fname):
    np1, np3 = 999., 999.
    if he5_fname is not None:
        fname = he5_fname
    else:
        fname = 'he5_%d/he5_A%d.out' % (aeff, aeff)
    f = open(fname)
    for line in f:
        if 'State # ' not in line:
            continue
        ldat = line.split()
        e = float(ldat[5])
        j = int(2 * float(ldat[8]))
        if j == 1 and np1 == 999.:
            np1 = e - e0
        if j == 3 and np3 == 999.:
            np3 = e - e0
        if np1 != 999. and np3 != 999.:
            break
    return np1, np3


def print_header(aeff, e0, spe):
    header_lines = list()
    header_lines.append(
        '!  Effective SM interaction generated by OLS and VCE with Aeff = '
        '%d' % (aeff,))
    header_lines.append('!  Zero body term: %10.6f' % (e0,))
    header_lines.append('!  Index  n  l  j tz')
    header_lines.append('!  1     0  1  1  1')
    header_lines.append('!  2     0  1  3  1')
    header_lines.append('! ')
    header_lines.append(
        '-999 ' + '  '.join(['%10.6f' % x for x in spe]) + '  4  6  0.000000')
    return '\n'.join(header_lines) + '\n'


def get_tbme(aeff, e0, spe, out_fname, he6_fname):
    write_lines = list()
    write_lines.append(print_header(aeff, e0, spe))
    if he6_fname is not None:
        fname = he6_fname
    else:
        fname = 'he6_%d/Heff_OLS.dat' % aeff
    f = open(fname)
    line = f.readline()
    dim = int(line.split()[0])
    kets = []
    for i in range(dim):
        ldat = f.readline().split()
        p, q = [int(x) for x in ldat[1:3]]
        j, t = [int(x) for x in ldat[9:11]]
        kets.append({'p': p, 'q': q, 'J': j, 'T': t})
    for i in range(dim):
        ldat = f.readline().split()
        for j in range(i, dim):
            if (kets[i]['J'], kets[i]['T']) != (kets[j]['J'], kets[j]['T']):
                continue
            v = float(ldat[j])
            if i == j:
                v -= e0 + spe[kets[i]['p'] - 1] + spe[kets[i]['q'] - 1]
            next_line = '%3d %3d %3d %3d  %3d %3d  %10.6f' % (
                kets[i]['p'], kets[i]['q'], kets[j]['p'], kets[j]['q'],
                kets[i]['J'], kets[i]['T'], v)
            write_lines.append(next_line + '\n')
    # write the file
    outfile = open(out_fname, 'w')
    for line in write_lines:
        outfile.write(line)
    outfile.close()


def run(aeff, out_fname, he4_fname=None, he5_fname=None, he6_fname=None):
    e0 = get_e0(aeff, he4_fname)
    spe = get_spe(aeff, e0, he5_fname)
    get_tbme(aeff, e0, spe, out_fname, he6_fname)

    # Do the inconsistent/universal way
    # Aeff = 6
    # E0 = GetE0(Aeff-2)
    # SPE = GetSPE(Aeff-1,E0)
    # GetTBME(Aeff,E0,SPE)


if len(argv) >= 3:
    aeff0 = int(argv[1])
    out_fname0 = argv[2]
    if len(argv) >= 6:
        he4_fname0 = argv[3]
        he5_fname0 = argv[4]
        he6_fname0 = argv[5]
    else:
        he4_fname0, he5_fname0, he6_name0 = (None,) * 3
    run(aeff=aeff0, out_fname=out_fname0,
        he4_fname=he4_fname0, he5_fname=he5_fname0, he6_fname=he6_fname0)
